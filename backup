#!/usr/bin/env python

from lib.database import get_database
from lib.defs import Console
from lib.menu import Menu
from lib.inlretro import dump_game
from lib.inesheader import write_with_header
from lib.util import input_or_exit
from os import close, path, remove
from shutil import copyfile
from tempfile import mkstemp

def console_to_display(console):
    if console == Console.nes:
        return 'NES'
    if console == Console.famicom:
        return 'Famicom'
    if console == Console.genesis:
        return 'Genesis/Mega Drive'
    
    return 'Unknown'

def version_to_listing(version):
    return "%s - %s" % (version.region, console_to_display(version.console))

def pick_game():
    game = None
    
    while game == None:
        name_index = None
        versions = []
        version_index = None

        # Search for games by name
        search = input_or_exit("\nSearch for game: ")

        # Search for results and have the user pick from them
        if len(search):
            name_suggestions = database.search(search)
            name_index = menu.select_item_index(name_suggestions)

        # If the user picked something, gather all versions of games by that name
        if name_index != None:
            name = name_suggestions[name_index]
            versions = sorted(
                database.get_games_by_name(name),
                key=lambda game: game.region
            )

        # If there is more than one version for that name, have the user pick one
        if len(versions) == 1:
            game = versions[0]
        elif len(versions) > 1:
            print("\nWhich version of %s?" % name)
            version_suggestions = map(version_to_listing, versions)
            version_index = menu.select_item_index(version_suggestions)
                
        if version_index != None:
            game = versions[version_index]

    return game

def pick_console():
    consoles = [Console.genesis, Console.nes, Console.famicom]
    options = map(console_to_display, consoles)
    index = menu.select_item_index(options)

    return consoles[index]

def get_extension(game):
    if game.console == Console.nes or game.console == Console.famicom:
        return 'nes'
    elif game.console == Console.genesis:
        return 'md'

    return ''

print("The INL Retro Cartridge Backup Helper")

menu = Menu()
console = pick_console()
database = get_database(console)
game = pick_game()

print("Creating backup for %s" % game.name)

# This is a little bit awkward, because we need the INL Retro subprocess to write to
# the tempfile first if this is NES/Famicom. Also: not sure if this works in Windows,
# but probably neither does anything else in here.
bin_fd, bin_filename = mkstemp()
close(bin_fd)

if dump_game(game, bin_filename):
    # NES/Famicom dumps need to write the final file with the NES2.0 header
    to_filename = "roms/%s (%s).%s" % (game.name, game.region, get_extension(game))

    if console == Console.nes or console == Console.famicom:
        write_with_header(game, bin_filename, to_filename)
    else:
        copyfile(bin_filename, to_filename)

    print("Wrote backup to\n\t%s" % to_filename)
        
else:
    print("Failed to read data from the cartridge.")

# Temp file cleanup
if console == Console.nes or console == Console.famicom:
    remove(bin_filename)

print("\nExiting...")
