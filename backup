#!/usr/bin/env python

from lib.database import get_database
from lib.defs import Console
from lib.menu import Menu
from lib.inlretro import dump_game
from lib.inesheader import write_with_header
from lib.util import input_or_exit
from os import close, path, remove
from shutil import copyfile
from tempfile import mkstemp

CONSOLE_OPTIONS = {
    Console.FAMICOM: 'NES/Famicom',
    Console.GENESIS: 'Genesis/Mega Drive',
    Console.NES: 'NES/Famicom',
    Console.N64: 'Nintendo 64',
}

CONSOLE_EXTENSIONS = {
    Console.FAMICOM: 'nes',
    Console.GENESIS: 'md',
    Console.NES: 'nes',
    Console.N64: 'z64',
}    

def version_to_listing(version):
    # Because of better, more granular cart info in the NES Cart DB, we can be more succint
    if version.console == Console.NES or version.console == Console.FAMICOM:
        return "%s - %s" % (version.region, version.console.value)
    else:
        return version.raw_name

def pick_game():
    game = None
    
    while game == None:
        name_index = None
        versions = []
        version_index = None

        # Search for games by name
        search = input_or_exit("\nSearch for game: ")

        # Search for results and have the user pick from them
        if len(search):
            name_suggestions = database.search(search)
            name_index = menu.select_item_index(name_suggestions)

        # If the user picked something, gather all versions of games by that name
        if name_index != None:
            name = name_suggestions[name_index]
            versions = sorted(
                database.get_games_by_name(name),
                key=lambda game: game.region
            )

        # If there is more than one version for that name, have the user pick one
        if len(versions) == 1:
            game = versions[0]
        elif len(versions) > 1:
            print("\nWhich version of %s?" % name)
            version_suggestions = map(version_to_listing, versions)
            version_index = menu.select_item_index(version_suggestions)
                
        if version_index != None:
            game = versions[version_index]

    return game

def pick_console():
    consoles = [Console.GENESIS, Console.NES, Console.N64]
    options = map(lambda c: CONSOLE_OPTIONS[c], consoles)
    index = menu.select_item_index(options)

    return consoles[index]

def get_extension(game):
    if game.console == Console.NES or game.console == Console.FAMICOM:
        return 'nes'
    elif game.console == Console.GENESIS:
        return 'md'

    return ''

print("The INL Retro Cartridge Backup Helper")

menu = Menu()
console = pick_console()
database = get_database(console)
game = pick_game()

print("Creating backup for %s" % game.name)

# This is a little bit awkward, because we need the INLretro subprocess to write to
# the tempfile first if this is NES/Famicom. Also: not sure if this works in Windows,
# but probably neither does anything else in here.
bin_fd, bin_filename = mkstemp()
close(bin_fd)

try:
    if dump_game(game, bin_filename):
        to_filename = "roms/%s (%s).%s" % (
            game.name,
            game.region,
            CONSOLE_EXTENSIONS[game.console]
        )

        # NES/Famicom dumps need to write the final file with the NES2.0 header
        if console == Console.NES or console == Console.FAMICOM:
            write_with_header(game, bin_filename, to_filename)
        else:
            copyfile(bin_filename, to_filename)

            print("Wrote backup to\n\t%s" % to_filename)
    
    else:
        print("Failed to read data from the cartridge.")

finally:
    # Temp file cleanup
    remove(bin_filename)

# Bye!
print("Exiting...")
